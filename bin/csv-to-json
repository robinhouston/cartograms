#!/usr/bin/python2.7
# We specify 2.7 because the comma extension to the format string language is very useful

"""Extract a JSON dictionary from a CSV file.
"""

import csv
import json
import optparse
import sys

parser = optparse.OptionParser()
parser.add_option("", "--rank",
                action="store_true",
                help="output the ranks rather than the values")
parser.add_option("", "--key",
                action="store",
                help="the column name of the key column")
parser.add_option("", "--value",
                action="store",
                help="the column name of the value column")
parser.add_option("", "--type",
                action="store", default="unicode",
                help="the type of the value column (default %default)")
parser.add_option("", "--format-string",
                action="store",
                help="format string for value output")

(options, args) = parser.parse_args(sys.argv[1:])
if not options.key:
    parser.error("The --key option must be specified")
if not options.value:
    parser.error("The --value option must be specified")
if len(args) > 1:
    parser.error("Too many arguments")

if not args:
    csv_file = sys.stdin
else:
    csv_file = open(args[0], 'r')

def munge_value(v):
    v = getattr(__builtins__, options.type)(v)
    if options.format_string:
        v = options.format_string.format(v)
    return v

r = csv.reader(csv_file)
header = r.next()
key_index = header.index(options.key)
value_index = header.index(options.value)

rows = ((
    (row[key_index].decode("utf-8"), munge_value(row[value_index].decode("utf-8")))
    for row in r
))
if options.rank:
    d = dict((
        (key, index+1)
        for index, (key, value) in enumerate(sorted(rows, key=lambda (key, value): value))
    ))
else:
    d = dict(rows)

json.dump(d, sys.stdout)

